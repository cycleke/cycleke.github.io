<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #551 (Div. 2)]]></title>
    <url>%2Fposts%2F43db3ce0%2F</url>
    <content type="text"><![CDATA[A. Serval and Bus算出t之后每班车的最早时间，取最小值 B. Serval and Toy Bricks每个有方块的位置尽可能取高，即min(a[j], b[i]) C. Serval and Parenthesis Sequence统计一下要放多少的(和),显然前面尽量放(是最优的，然后check判断 D. Serval and Rooted Tree考虑最下面两层，如果答案再这棵子树中，那么: 如果是min操作，$ ans = k - leaves + 1 $ 如果是max操作，$ ans = leaves = k - 1 + 1 $ 我们定义f[i]为i子树中的有效叶子，那么ans = k - f[1] + 1，且: 如果是min操作，$ f[u] = sum(f[v]) $ 如果是max操作，$ f[u] = min(f[v]) $ E. Serval and Snake不难发现如果一个矩阵中有一端，那么交点为奇数， 然后乱搞就好了枚举找到头和尾的行或者列，然后二分就好了。 然而可怜的cycleke常用二分方法超限了，不得不临时想(猜)其他方法]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #549 (Div. 2)]]></title>
    <url>%2Fposts%2F9182a3d4%2F</url>
    <content type="text"><![CDATA[A.The Doors记录最后一个0和1的位置。 B.Nirvana对于每一位,答案有三种情况: 1,取这位原本数字; 2,取x-1,同时让后一位取9; 3,让前面全取9; C.Queen一个点如果会被删，那么其他的点被删不会影响它最后被删的结果，判断一下那些点会被删，然后排序。 D.The Beatles显然\( L = c \times k + a - b \) 或 \( L = c \times k - a - b \)，对于每个L，$$ step =lcm(n \times k,L) / L = n \times k / gcd(n \times k, L) $$ c从1取到n。 E.Lynyrd Skynyrd设begin_p[i]为以i结尾的环排列起点的最大位置，用倍增求begin_p[i],用前缀和优化就可以解决。 F.U2对于每一个抛物线，满足\( x_i^2 + bx_i + c \geq y_i \)，即\( x_i*b + c \geq y_i-x_i^2 \)，然后求个凸包，答案是交点个数。]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
</search>
